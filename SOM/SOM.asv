% data  - Conj de dados
% Ns - Qtd de neuronios de saida
% dim   - [Nx Ny] (Nx*Ny=Ns)
% topology  - 'hex' ou 'rec'
%function [ output_args ] = SOM( data, Ns, dim, topology)
function [ output_args ] = SOM( data, Ns, dim, topology)

Ns = dim(1)*dim(2);
neuronsGrid = [ceil((1:Ns)/dim(1));mod((0:Ns-1),dim(1))+1]';

% DEFINIÇÃO DE VARIÁVEIS
[n,D] = size(data); 
% n - qtd exemplos d  e dados
% D - Dimensão original do problema
alfa = .1;
% alfa - Taxa de aprendizado
radius = max(dim)/2;
% raio - Raio de vizinhança
fDist = 'e';
% fDist - Função de distância utilizada ('e' euclidiana ou 'm' manhattan )
itMax = 100;
% itMax - Num máximo de iterações
it = 1;
% it - Contador de iterações

% INICIA PROTÓTIPOS RANDOMICAMENTE
maximo = max(data);   %valores máximos de cada dimensão original
minimo = min(data);   %valores minimos de cada dimensão original
W = repmat(minimo,Ns,1)+repmat(maximo-minimo,Ns,1).*rand(Ns,D);
%W - Pesos de cada neuronio. Localização no espaço dimensional D original

% PROCESSO ITERATIVO
while (it<itMax)
  it = it + 1;
  for i=1:n %iteração em todos as instancias
    p = data(i,:);
    %p - ponto vetorial da instancia i
    D = distance(p,W,fDist);
    %D - Distancia do ponto p para a posição dos neuronios W
    
    [~,BMU] = min(D);
    %BMU - Neuronio mais próximo de p
    
    theta = neighborhood(W,topology,radius,BMU,it);
    %theta - Matriz de pesos para atualização dos vizinhos do BMU
    
    % ATUALIZA OS PESOS W
    P = repmat(p,Ns,1);
    W = W + theta*alfa*(P-W);
    
  end
  
  % ALTERA A TAXA  DE APRENDIZADO  
  %20*exp(-7/1)
  %raioIni*exp(-it/1) diminuição do raio
  %alfaIni*exp(-it/lambda) diminuição do alfa
  
end

end

function [theta] = neighborhood(W,dim,topology,radius,BMU,t)
  tau = 5;
  
  if strcmp(topology, 'gauss')
    radius = radius*exp(-t/tau);
    D = distance();
    theta = exp(-D./(2*radius^2))
  elseif strcmp(topology, 'hex')
  elseif strcmp(topology, 'rec')
    
  end
  
end

% FUNÇÃO DE DISTÂNCIAS
% calcula a distancia do ponto p aos pontos em POINTS
% de acordo com uma distancia (dist) euclidiana ('e') ou manhattan ('m')
function D = distance(p, POINTS, fDist)
  [n,~] = size(POINTS);
  P = repmat(p,n,1);
  if strcmp(fDist,'e') %distancia euclidiana
    D = sqrt(sum((P-POINTS).^2, 2));
  elseif strcmp(fDist,'m') %distancia manhattan
    D = sum(abs(P-POINTS), 2);
  end
end
